// MiniDynLang test suite

// --- Test harness ------------------------------------------------------------
let TOTAL = 0;
let PASSED = 0;
let FAILED = 0;
let FAILS = [];

let EPS = 1e-9;

fn show(v) {
    let t = type(v);
    if (t == "object" or t == "array") return json_stringify(v);
    return to_string(v);
}

fn almost_number_equal(a, b) {
    // numbers: allow tiny tolerance for doubles
    if (a == b) return true;
    return abs(a - b) < EPS;
}

fn deep_equal(a, b) {
    let ta = type(a);
    let tb = type(b);

    // Allow numeric-string equality by numeric conversion (as the interpreter does)
    if (ta != tb) {
        if ((ta == "number" and tb == "string") or (ta == "string" and tb == "number")) {
            return to_number(a) == to_number(b);
        }
        return false;
    }

    if (ta == "number") return almost_number_equal(a, b);
    if (ta == "string" or ta == "boolean" or ta == "nil") return a == b;

    if (ta == "array") {
        if (length(a) != length(b)) return false;
        let i = 0;
        while (i < length(a)) {
            if (not deep_equal(a[i], b[i])) return false;
            i = i + 1;
        }
        return true;
    }

    if (ta == "object") {
        let ka = sort(keys(a));
        let kb = sort(keys(b));
        if (not deep_equal(ka, kb)) return false;
        let i = 0;
        while (i < length(ka)) {
            let k = ka[i];
            if (not deep_equal(a[k], b[k])) return false;
            i = i + 1;
        }
        return true;
    }

    // functions and others: reference equality only (not used for deep compares)
    return a == b;
}

fn record(ok, name, got, exp) {
    TOTAL = TOTAL + 1;
    if (ok) {
        PASSED = PASSED + 1;
        println("ok ", TOTAL, " - ", name);
    } else {
        FAILED = FAILED + 1;
        push(FAILS, name);
        println("not ok ", TOTAL, " - ", name);
        if (type(exp) != "nil") {
            println("   got: ", show(got));
            println("   exp: ", show(exp));
        } else {
            println("   got: ", show(got));
        }
    }
}

fn test_true(name, cond) {
    record(not not cond, name, cond, true);
}

fn test_eq(name, got, exp) {
    let ok = deep_equal(got, exp);
    record(ok, name, got, exp);
}

fn section(name) {
    println();
    println("## ", name);
    println();
}

// --- Tests -------------------------------------------------------------------

// Numbers and arithmetic
section("Numbers and arithmetic");
test_eq("1 + 2 == 3", 1 + 2, 3);
test_eq("2*3 + 4 == 10", 2 * 3 + 4, 10);
test_eq("7 / 2 == 3.5", 7 / 2, 3.5);
test_eq("8 / 2 == 4", 8 / 2, 4);
test_eq("7 % 3 == 1", 7 % 3, 1);
test_eq("unary minus", -5, -5);

// BigInt arithmetic (just beyond int64)
let big = 9223372036854775808;
test_eq("BigInt add", big + 5, 9223372036854775813);

// Comparisons
test_true("3 < 5", 3 < 5);
test_true("5 >= 5", 5 >= 5);
test_true("10 == '10' (numeric-string equality)", 10 == "10");

// Logical ops and short-circuit
section("Logical ops and short-circuit");
let side = 0;
fn inc() { side = side + 1; return true; }
test_eq("false and inc() doesn't call inc", (fn(){ false and inc(); return side; })(), 0);
test_eq("true or inc() doesn't call inc",   (fn(){ true or inc();   return side; })(), 0);
test_eq("true and inc() calls inc once",    (fn(){ true and inc();  return side; })(), 1);
test_eq("false or inc() calls inc twice total", (fn(){ false or inc(); return side; })(), 2);

// Ternary
section("Ternary");
test_eq("1<2 ? 'yes' : 'no'", (1 < 2) ? "yes" : "no", "yes");

// Comma operator
section("Comma operator");

// Basic behavior
test_eq("chained comma returns last", (1, 2, 3), 3);
test_eq("basic: left-to-right; return right", (fn(){ let x = 0; x = 1, x = x + 2; return x; })(), 3);
test_eq("order of side effects", (fn(){ let log=[]; push(log,"a"), push(log,"b"); return log; })(), ["a","b"]);
test_eq("assignment happens on left", (fn(){ let a=0; (a=1, 42); return a; })(), 1);
test_eq("lowest precedence with + and =", (fn(){ let a=0; return (a=1, a+1); })(), 2);

// In function args (must parenthesize to treat as one value)
fn pair(a, b) { return [a, b]; }
test_eq("paren comma as single arg", pair((1,2), 3), [2,3]);
test_eq("paren comma in second arg", pair(1, (2,3)), [1,3]);

// In array and object literals (with parentheses)
test_eq("array element with paren-comma", [(1,2), 3], [2,3]);
test_eq("object value with paren-comma", { a: (1,2), b: 3 }, { a: 2, b: 3 });

// In index and computed keys
test_eq("index with paren-comma", (fn(){ let a=[10,11,12]; return a[(1,2)]; })(), 12);
test_eq("computed key with paren-comma", (fn(){ let o = { [(1,2)]: 5 }; return o["2"]; })(), 5);

// With named arguments (value can be paren-comma)
fn mk(name, age = 25) { return { name: name, age: age }; }
test_eq("named arg with paren-comma", mk(name: ("Bob","Zed")), { name: "Zed", age: 25 });

// In while condition (comma returns the last value)
test_eq("comma in while condition", (fn(){
    let seq = []; let i = 0;
    while ((push(seq, i), i = i + 1, i < 3)) { }
    return seq;
})(), [0,1,2]);

// In ternary arms when parenthesized
test_eq("ternary arm may use paren-comma", (true ? (1,2) : 3), 2);
test_eq("ternary else with paren-comma", (false ? 1 : (3,4)), 4);

// Strings
section("Strings");
test_eq("'abc' + 'def'", "abc" + "def", "abcdef");
test_eq("substring('abcdef',2,3)", substring("abcdef", 2, 3), "cde");
test_eq("index_of('hello','lo')", index_of("hello", "lo"), 3);
test_true("contains('hello','ell')", contains("hello", "ell"));
test_true("starts_with('hello','he')", starts_with("hello", "he"));
test_true("ends_with('hello','lo')", ends_with("hello", "lo"));
test_eq("trim('  a  ')", trim("  a  "), "a");
test_eq("split/join", join(split("a,b,c", ","), "-"), "a-b-c");
test_eq("to_upper", to_upper("Abc!"), "ABC!");
test_eq("to_lower", to_lower("AbC!"), "abc!");

// Indexing string
test_eq("'Hello'[1] == 'e'", "Hello"[1], "e");

// Arrays
section("Arrays");
let arr1 = [1, 2, 3];
test_eq("length([1,2,3])", length(arr1), 3);
let arr2 = [1, , 3];
test_eq("elision makes hole (nil) at index 1", type(arr2[1]), "nil");

let arr3 = [];
push(arr3, 10, 20, 30);
test_eq("push adds elements", arr3, [10, 20, 30]);
test_eq("pop returns last", pop(arr3), 30);
test_eq("pop removed last", arr3, [10, 20]);

arr3[0] += 2;
test_eq("index compound assignment", arr3, [12, 20]);

test_eq("array concatenation with +", [1, 2] + [3, 4], [1, 2, 3, 4]);
test_eq("slice([1,2,3,4], -2)", slice([1, 2, 3, 4], -2), [3, 4]);
test_eq("at negative index", at([9, 8, 7], -1), 7);

test_eq("join(['a','b'],'|')", join(["a", "b"], "|"), "a|b");

// Higher-order
let nums = [1, 2, 3, 4, 5, 2, 3];
test_eq("map x*2", map(nums, x => x * 2), [2, 4, 6, 8, 10, 4, 6]);
test_eq("filter x>2", filter(nums, x => x > 2), [3, 4, 5, 3]);
test_eq("reduce sum with init", reduce(nums, (a, b) => a + b, 0), 20);
test_eq("sort default asc", sort([3, 1, 2]), [1, 2, 3]);
test_eq("sort with comparator desc", sort([3, 1, 2], (a, b) => b - a), [3, 2, 1]);
test_eq("unique", unique(nums), [1, 2, 3, 4, 5]);
test_eq("range(5)", range(5), [0, 1, 2, 3, 4]);
test_eq("range(2,8,2)", range(2, 8, 2), [2, 4, 6]);

// Arrays: set_at and clone
let arr4 = [5, 6, 7];
set_at(arr4, 1, 42);
test_eq("set_at", arr4, [5, 42, 7]);
let arr4c = clone(arr4);
test_eq("clone array", arr4c, [5, 42, 7]);

// Objects
section("Objects");
let o = { a: 1, b: 2, c: { d: 3 } };
test_eq("dot access", o.a, 1);
test_eq("bracket access", o["b"], 2);
test_eq("nested", o.c.d, 3);

let k = "x";
let o2 = { [k + "1"]: 11, [k + "2"]: 22 };
test_eq("computed keys", [o2["x1"], o2["x2"]], [11, 22]);

let merged = merge(o, o2);
test_true("has_key merged 'x2'", has_key(merged, "x2"));
test_eq("remove_key", (fn(){ remove_key(merged, "x1"); return has_key(merged, "x1"); })(), false);

test_eq("keys sorted", sort(keys(o)), ["a", "b", "c"]);
test_eq("values unordered check via sort after stringify",
    sort(map(values({ q: 1, w: 2, e: 3 }), to_string)),
    ["1", "2", "3"]);

let entries_o = entries({ k1: 1, k2: 2 });
let rebuilt = from_entries(entries_o);
test_eq("from_entries(entries(obj)) roundtrip", rebuilt, { k1: 1, k2: 2 });

// Object assignment
o.a += 5;
o["b"] = o["b"] * 10;
test_eq("compound prop ops", [o.a, o.b], [6, 20]);

// Functions
section("Functions");
fn add(a, b) { return a + b; }
test_eq("fn add", add(5, 7), 12);

fn greet(name, greeting = "Hi") { return greeting + ", " + name; }
test_eq("default param used", greet("World"), "Hi, World");
test_eq("default param overridden", greet("Alice", "Hello"), "Hello, Alice");

fn sum(...nums) {
    let t = 0;
    let i = 0;
    while (i < length(nums)) { t = t + nums[i]; i = i + 1; }
    return t;
}
test_eq("rest param sum", sum(1, 2, 3, 4), 10);

// Named arguments
fn createUser(name, age = 25, city = "Unknown", active = true) {
    return { name: name, age: age, city: city, active: active };
}
test_eq("positional createUser", createUser("Alice", 28, "NY", true),
    { name: "Alice", age: 28, city: "NY", active: true });
test_eq("named args createUser", createUser(name: "Bob", city: "London", age: 35),
    { name: "Bob", age: 35, city: "London", active: true });
test_eq("mixed named/positional", createUser("Charlie", city: "Tokyo", active: false),
    { name: "Charlie", age: 25, city: "Tokyo", active: false });

// Arrow functions
let dbl = x => x * 2;
test_eq("arrow single param", dbl(7), 14);

let arrowAdd = (x, y) => x + y;
test_eq("arrow two params", arrowAdd(2, 3), 5);

let fact = n => { if (n <= 1) return 1; return n * fact(n - 1); };
test_eq("arrow block body recursion", fact(6), 720);

// 'this' binding
section("'this' binding");
let counter = {
    n: 0,
    inc: fn() { this.n = this.n + 1; return this.n; },
    makeArrowGetter: fn() { return () => this.n; },
    makeNormalGetter: fn() { return fn() { return this.n; }; }
};

counter.inc(); // 1
counter.inc(); // 2
let getArrow = counter.makeArrowGetter();
let getNormal = counter.makeNormalGetter();
test_eq("arrow captures lexical this", getArrow(), 2);

let other = { n: 100 };
other.get = getArrow;
test_eq("arrow ignores rebinding", other.get(), 2);

other.get = getNormal;
test_eq("normal respects call-site this", other.get(), 100);

// Methods on object
let person = {
    name: "John",
    age: 30,
    greet: fn() { return "Hello, I'm " + this.name + " and I'm " + this.age + " years old."; },
    haveBirthday: fn() { this.age = this.age + 1; return this.age; }
};
test_eq("method uses this", person.greet(), "Hello, I'm John and I'm 30 years old.");
test_eq("mutating method", person.haveBirthday(), 31);

// Destructuring declarations and assignment
section("Destructuring");
let [a, b = 2, ...rest] = [1, , 3, 4, 5];
test_eq("array destructuring decl", [a, b, rest], [1, 2, [3, 4, 5]]);

const { x: xx, y, z = 7, ...others } = { x: 1, y: 2, w: 9 };
test_eq("object destructuring decl with alias/default/rest",
    [xx, y, z, others], [1, 2, 7, { w: 9 }]);

[a, b] = [10, 20];
test_eq("array destructuring assignment", [a, b], [10, 20]);

let target = { a: 0, b: 0 };
{ a: target.a, b: target.b } = { a: 5, b: 6 };
test_eq("object destructuring assignment into properties", target, { a: 5, b: 6 });

// Member calls + rest-last with named args
section("Parameters: rest-last and named arguments");
fn restLastDemo(a, b = 2, ...r) { return { a: a, b: b, rest: r }; }
test_eq("restLastDemo(1)", restLastDemo(1), { a: 1, b: 2, rest: [] });
test_eq("restLastDemo(1,3,4,5)", restLastDemo(1, 3, 4, 5), { a: 1, b: 3, rest: [4, 5] });
test_eq("restLastDemo(b:10,a:7,8,9)", restLastDemo(b: 10, a: 7, 8, 9), { a: 7, b: 10, rest: [8, 9] });

// JSON roundtrip
section("JSON");
let objJ = { msg: "ok", data: [1, 2, 3], nested: { a: 1 } };
let j = json_stringify(objJ);
let parsed = json_parse(j);
test_eq("json round-trip deep equal", parsed, objJ);

// Random determinism by reseeding
section("Random with seed");
srand(123);
let r1 = random();
srand(123);
let r2 = random();
test_true("random repeatable after same seed", almost_number_equal(r1, r2));

// --- Logical alias operators (&&, ||, !) --------------------------------
section("Logical alias operators (&&, ||, !)");
test_eq("false && does not eval right", (fn(){
    let s = 0;
    fn inc2() { s = s + 1; return true; }
    false && inc2();
    return s;
})(), 0);

test_eq("true || does not eval right", (fn(){
    let s = 0;
    fn inc2() { s = s + 1; return true; }
    true || inc2();
    return s;
})(), 0);

test_eq("true && evals right once", (fn(){
    let s = 0;
    fn inc2() { s = s + 1; return true; }
    true && inc2();
    return s;
})(), 1);

test_true("!false is true", !false);
test_true("!(1 < 2 && false) is true", !(1 < 2 && false));
test_true("1 < 2 && 3 < 4", 1 < 2 && 3 < 4);
test_true("1 < 2 || 3 < 1", 1 < 2 || 3 < 1);
test_true("1 != 2", 1 != 2);

// --- Object insertion order and iteration -------------------------------
section("Object insertion order and iteration");
let ord = { b: 1, a: 2, c: 3 };
test_eq("keys preserve insertion order", keys(ord), ["b", "a", "c"]);
test_eq("entries preserve insertion order", map(entries(ord), e => e[0]), ["b", "a", "c"]);
test_eq("json_stringify preserves order", json_stringify(ord), "{\"b\":1,\"a\":2,\"c\":3}");
test_eq("merge preserves base order and appends",
    keys(merge({ a: 1 }, { b: 2, a: 3, c: 4 })), ["a", "b", "c"]);
test_eq("updating existing key does not reorder", (fn(){
    let o = { a: 1, b: 2, c: 3 };
    o.b = 9;
    return keys(o);
})(), ["a", "b", "c"]);
test_eq("adding new key appends at end", (fn(){
    let o = { a: 1, b: 2 };
    o.c = 3;
    return keys(o);
})(), ["a", "b", "c"]);

// Try/Catch/Finally & Throw
section("Try/Catch/Finally and Throw");

// Catch a thrown literal
test_eq("catch literal thrown", (fn(){
    let got = nil;
    try { throw 123; }
    catch (e) { got = e; }
    return got;
})(), 123);

// finally runs on normal path
test_eq("finally executes on normal path", (fn(){
    let f = 0;
    try { f = 1; }
    finally { f = f + 1; }
    return f;
})(), 2);

// finally runs on throw
test_eq("finally executes on throw", (fn(){
    let f = 0;
    try { throw "x"; }
    catch (e) { }
    finally { f = 42; }
    return f;
})(), 42);

// raise() throws an Error object
test_eq("raise() produces Error object", (fn(){
    let got = nil;
    try { raise("boom"); }
    catch (e) { got = [e.name, e.message]; }
    return got;
})(), ["Error", "boom"]);

// error() returns an Error object (not thrown)
test_eq("error() returns object", (fn(){
    let e = error("just an object");
    return [e.name, e.message];
})(), ["Error", "just an object"]);

// Catch a runtime error as value
test_eq("catch runtime error as value", (fn(){
    let got = nil;
    try {
        let x = 1 / 0; // Division by zero -> runtime error
    } catch (e) {
        got = [e.name, contains(e.message, "Division by zero")];
    }
    return got;
})(), ["RuntimeError", true]);

// catch without binding
test_eq("catch without binding", (fn(){
    let f = 0;
    try { throw "oops"; }
    catch { f = 7; }
    return f;
})(), 7);

// finally runs even when returning from try
let tracking2 = { flag: 0 };
fn f_finally() {
    try { return 10; }
    finally { tracking2.flag = tracking2.flag + 1; }
}
test_eq("finally runs on return", (fn(){
    tracking2.flag = 0;
    let r = f_finally();
    return [r, tracking2.flag];
})(), [10, 1]);

// --- Recursion and Tail-Call Optimization -----------------------------------
section("Recursion and Tail-Call Optimization");

// 1) Tail-recursive factorial (normal function)
fn tco_fact(n, acc = 1) {
    if (n <= 1) return acc;
    return tco_fact(n - 1, acc * n);
}
test_eq("tco_fact(5)", tco_fact(5), 120);

// 2) Tail-recursive factorial (arrow function)
let tco_fact2 = (n, acc = 1) => n <= 1 ? acc : tco_fact2(n - 1, acc * n);
test_eq("tco_fact2(6)", tco_fact2(6), 720);

// 3) Deep tail recursion should not overflow the host stack
fn tco_countdown(n) {
    if (n == 0) return 0;
    return tco_countdown(n - 1);
}
let tco_deep = 20000;
test_eq("tco_countdown(20000)", tco_countdown(tco_deep), 0);

// 4) Tail call via callee expression with side effects (callee evaluated once)
let tco_side = 0;
let tco_get_countdown = () => { tco_side = tco_side + 1; return tco_countdown; };
fn tco_countdown2(n) {
    if (n == 0) return 0;
    return tco_get_countdown()(n - 1); // callee side-effect must still happen once
}
let tco_steps = 1000;
test_eq("tco_countdown2(1000)", tco_countdown2(tco_steps), 0);
test_eq("callee side-effects (1000)", tco_side, 1);

// 5) Non-tail recursion path should still work (no optimization)
fn tco_sum1(n) {
    if (n == 0) return 0;
    return 1 + tco_sum1(n - 1); // not a tail position
}
test_eq("tco_sum1(100)", tco_sum1(100), 100);

// 6) Named/default params preserved across tail calls
fn tco_bump_to(a, b = 10) {
    if (a <= 0) return b;
    return tco_bump_to(a - 1, b: b + 1); // named argument in tail position
}
test_eq("tco_bump_to(5, b:0)", tco_bump_to(5, b: 0), 5);
test_eq("tco_bump_to(3)", tco_bump_to(3), 13);

// 7) Tail recursion via method call (same function identity via property)
let tco_obj = {};
tco_obj.m = fn(n) {
    if (n == 0) return 0;
    return tco_obj.m(n - 1);
};
test_eq("tco_obj.m(1500)", tco_obj.m(1500), 0);

// 8) Arrow method variant
let tco_obj2 = {};
tco_obj2.m = (n, acc = 0) => n == 0 ? acc : tco_obj2.m(n - 1, acc + 1);
test_eq("tco_obj2.m(200)", tco_obj2.m(200), 200);

// --- Summary -----------------------------------------------------------------
println();
println("===== SUMMARY =====");
println("Total: ", TOTAL, "  Passed: ", PASSED, "  Failed: ", FAILED);
if (FAILED > 0) {
    println("Failed tests:");
    let i = 0;
    while (i < length(FAILS)) { println(" - ", FAILS[i]); i = i + 1; }
}
