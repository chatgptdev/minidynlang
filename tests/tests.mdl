// MiniDynLang test suite

// --- Test harness ------------------------------------------------------------
let TOTAL = 0;
let PASSED = 0;
let FAILED = 0;
let FAILS = [];

let EPS = 1e-9;

fn show(v) {
    let t = type(v);
    if (t == "object" or t == "array") return json_stringify(v);
    return to_string(v);
}

fn almost_number_equal(a, b) {
    // numbers: allow tiny tolerance for doubles
    if (a == b) return true;
    return abs(a - b) < EPS;
}

fn record(ok, name, got, exp) {
    TOTAL = TOTAL + 1;
    if (ok) {
        PASSED = PASSED + 1;
        println("ok ", TOTAL, " - ", name);
    } else {
        FAILED = FAILED + 1;
        push(FAILS, name);
        println("not ok ", TOTAL, " - ", name);
        if (type(exp) != "nil") {
            println("   got: ", show(got));
            println("   exp: ", show(exp));
        } else {
            println("   got: ", show(got));
        }
    }
}

fn test_true(name, cond) {
    record(not not cond, name, cond, true);
}

fn test_eq(name, got, exp) {
    let ok = deep_equal(got, exp);
    record(ok, name, got, exp);
}

fn section(name) {
    println();
    println("## ", name);
    println();
}

// --- Tests -------------------------------------------------------------------

// Numbers and arithmetic
section("Numbers and arithmetic");
test_eq("1 + 2 == 3", 1 + 2, 3);
test_eq("2*3 + 4 == 10", 2 * 3 + 4, 10);
test_eq("7 / 2 == 3.5", 7 / 2, 3.5);
test_eq("8 / 2 == 4", 8 / 2, 4);
test_eq("7 % 3 == 1", 7 % 3, 1);
test_eq("unary minus", -5, -5);

// Number literal formats: hex, binary, underscores in digits and exponent
test_eq("hex literal 0xFF == 255", 0xFF, 255);
test_eq("binary literal 0b1010_0011 == 163", 0b1010_0011, 163);
test_eq("underscores in decimal int", 1_234_567 + 3, 1234570);
test_eq("underscores in float", 12_34.5_6, 1234.56);
test_eq("underscores in exponent", 1e1_0, 10000000000);

// BigInt arithmetic (just beyond int64)
let big = 9223372036854775808;
test_eq("BigInt add", big + 5, 9223372036854775813);

// Comparisons
test_true("3 < 5", 3 < 5);
test_true("5 >= 5", 5 >= 5);
test_true("10 == '10' (numeric-string equality)", 10 == "10");

// Logical ops and short-circuit
section("Logical ops and short-circuit");
let side = 0;
fn inc() { side = side + 1; return true; }
test_eq("false and inc() doesn't call inc", (fn(){ false and inc(); return side; })(), 0);
test_eq("true or inc() doesn't call inc",   (fn(){ true or inc();   return side; })(), 0);
test_eq("true and inc() calls inc once",    (fn(){ true and inc();  return side; })(), 1);
test_eq("false or inc() calls inc twice total", (fn(){ false or inc(); return side; })(), 2);

// Ternary
section("Ternary");
test_eq("1<2 ? 'yes' : 'no'", (1 < 2) ? "yes" : "no", "yes");

// Comma operator
section("Comma operator");

// Basic behavior
test_eq("chained comma returns last", (1, 2, 3), 3);
test_eq("basic: left-to-right; return right", (fn(){ let x = 0; x = 1, x = x + 2; return x; })(), 3);
test_eq("order of side effects", (fn(){ let log=[]; push(log,"a"), push(log,"b"); return log; })(), ["a","b"]);
test_eq("assignment happens on left", (fn(){ let a=0; (a=1, 42); return a; })(), 1);
test_eq("lowest precedence with + and =", (fn(){ let a=0; return (a=1, a+1); })(), 2);

// In function args (must parenthesize to treat as one value)
fn pair(a, b) { return [a, b]; }
test_eq("paren comma as single arg", pair((1,2), 3), [2,3]);
test_eq("paren comma in second arg", pair(1, (2,3)), [1,3]);

// In array and object literals (with parentheses)
test_eq("array element with paren-comma", [(1,2), 3], [2,3]);
test_eq("object value with paren-comma", { a: (1,2), b: 3 }, { a: 2, b: 3 });

// In index and computed keys
test_eq("index with paren-comma", (fn(){ let a=[10,11,12]; return a[(1,2)]; })(), 12);
test_eq("computed key with paren-comma", (fn(){ let o = { [(1,2)]: 5 }; return o["2"]; })(), 5);

// With named arguments (value can be paren-comma)
fn mk(name, age = 25) { return { name: name, age: age }; }
test_eq("named arg with paren-comma", mk(name: ("Bob","Zed")), { name: "Zed", age: 25 });

// In while condition (comma returns the last value)
test_eq("comma in while condition", (fn(){
    let seq = []; let i = 0;
    while ((push(seq, i), i = i + 1, i < 3)) { }
    return seq;
})(), [0,1,2]);

// In ternary arms when parenthesized
test_eq("ternary arm may use paren-comma", (true ? (1,2) : 3), 2);
test_eq("ternary else with paren-comma", (false ? 1 : (3,4)), 4);

// Strings
section("Strings");
test_eq("'abc' + 'def'", "abc" + "def", "abcdef");
test_eq("substring('abcdef',2,3)", substring("abcdef", 2, 3), "cde");
test_eq("index_of('hello','lo')", index_of("hello", "lo"), 3);
test_true("contains('hello','ell')", contains("hello", "ell"));
test_true("starts_with('hello','he')", starts_with("hello", "he"));
test_true("ends_with('hello','lo')", ends_with("hello", "lo"));
test_eq("trim('  a  ')", trim("  a  "), "a");
test_eq("split/join", join(split("a,b,c", ","), "-"), "a-b-c");
test_eq("to_upper", to_upper("Abc!"), "ABC!");
test_eq("to_lower", to_lower("AbC!"), "abc!");

// Indexing string
test_eq("'Hello'[1] == 'e'", "Hello"[1], "e");

// String interpolation
let who = "Alice";
test_eq("interpolation: simple $ {name}", "Hello, ${who}!", "Hello, Alice!");
test_eq("interpolation: expression ${1+2}", "1 + 2 = ${1 + 2}", "1 + 2 = 3");
//test_eq("interpolation: multiple parts", "${'a'}-${'b'}-${'c'}", "a-b-c");
//test_eq("interpolation with call", "len=${length('abcd')}", "len=4");

// Escapes in normal strings
let str_newline = """a
b""";
test_eq("escape \\n", "a\nb", str_newline);
test_eq("escape \\t", "a\tb", """a	b""");
test_eq("escape \\x41 == 'A'", "\x41", "A");
test_eq("escape \\u03A9 == 'Ω'", "\u03A9", "Ω");
test_eq("escape backslash and quote", " \\\" ", """ \" """);

// Raw multiline strings """..."""
let raw1 = """first line
second "quote" line
third line""";
test_eq("raw multiline content preserved", raw1, "first line\nsecond \"quote\" line\nthird line");
test_eq("raw does not interpret escapes", """A \n B\tC""", "A \\n B\\tC");

// Arrays
section("Arrays");
let arr1 = [1, 2, 3];
test_eq("length([1,2,3])", length(arr1), 3);
let arr2 = [1, , 3];
test_eq("elision makes hole (nil) at index 1", type(arr2[1]), "nil");

let arr3 = [];
push(arr3, 10, 20, 30);
test_eq("push adds elements", arr3, [10, 20, 30]);
test_eq("pop returns last", pop(arr3), 30);
test_eq("pop removed last", arr3, [10, 20]);

arr3[0] += 2;
test_eq("index compound assignment", arr3, [12, 20]);

test_eq("array concatenation with +", [1, 2] + [3, 4], [1, 2, 3, 4]);
test_eq("slice([1,2,3,4], -2)", slice([1, 2, 3, 4], -2), [3, 4]);
test_eq("at negative index", at([9, 8, 7], -1), 7);

test_eq("join(['a','b'],'|')", join(["a", "b"], "|"), "a|b");

// Higher-order
let nums = [1, 2, 3, 4, 5, 2, 3];
test_eq("map x*2", map(nums, x => x * 2), [2, 4, 6, 8, 10, 4, 6]);
test_eq("filter x>2", filter(nums, x => x > 2), [3, 4, 5, 3]);
test_eq("reduce sum with init", reduce(nums, (a, b) => a + b, 0), 20);
test_eq("sort default asc", sort([3, 1, 2]), [1, 2, 3]);
test_eq("sort with comparator desc", sort([3, 1, 2], (a, b) => b - a), [3, 2, 1]);
test_eq("unique", unique(nums), [1, 2, 3, 4, 5]);
test_eq("range(5)", range(5), [0, 1, 2, 3, 4]);
test_eq("range(2,8,2)", range(2, 8, 2), [2, 4, 6]);

// Arrays: set_at and clone
let arr4 = [5, 6, 7];
set_at(arr4, 1, 42);
test_eq("set_at", arr4, [5, 42, 7]);
let arr4c = clone(arr4);
test_eq("clone array", arr4c, [5, 42, 7]);

// Objects
section("Objects");
let o = { a: 1, b: 2, c: { d: 3 } };
test_eq("dot access", o.a, 1);
test_eq("bracket access", o["b"], 2);
test_eq("nested", o.c.d, 3);

let k = "x";
let o2 = { [k + "1"]: 11, [k + "2"]: 22 };
test_eq("computed keys", [o2["x1"], o2["x2"]], [11, 22]);

let merged = merge(o, o2);
test_true("has_key merged 'x2'", has_key(merged, "x2"));
test_eq("remove_key", (fn(){ remove_key(merged, "x1"); return has_key(merged, "x1"); })(), false);

test_eq("keys sorted", sort(keys(o)), ["a", "b", "c"]);
test_eq("values unordered check via sort after stringify",
    sort(map(values({ q: 1, w: 2, e: 3 }), to_string)),
    ["1", "2", "3"]);

let entries_o = entries({ k1: 1, k2: 2 });
let rebuilt = from_entries(entries_o);
test_eq("from_entries(entries(obj)) roundtrip", rebuilt, { k1: 1, k2: 2 });

// Object assignment
o.a += 5;
o["b"] = o["b"] * 10;
test_eq("compound prop ops", [o.a, o.b], [6, 20]);

// Functions
section("Functions");
fn add(a, b) { return a + b; }
test_eq("fn add", add(5, 7), 12);

fn greet(name, greeting = "Hi") { return greeting + ", " + name; }
test_eq("default param used", greet("World"), "Hi, World");
test_eq("default param overridden", greet("Alice", "Hello"), "Hello, Alice");

fn sum(...nums) {
    let t = 0;
    let i = 0;
    while (i < length(nums)) { t = t + nums[i]; i = i + 1; }
    return t;
}
test_eq("rest param sum", sum(1, 2, 3, 4), 10);

// Named arguments
fn createUser(name, age = 25, city = "Unknown", active = true) {
    return { name: name, age: age, city: city, active: active };
}
test_eq("positional createUser", createUser("Alice", 28, "NY", true),
    { name: "Alice", age: 28, city: "NY", active: true });
test_eq("named args createUser", createUser(name: "Bob", city: "London", age: 35),
    { name: "Bob", age: 35, city: "London", active: true });
test_eq("mixed named/positional", createUser("Charlie", city: "Tokyo", active: false),
    { name: "Charlie", age: 25, city: "Tokyo", active: false });

// Arrow functions
let dbl = x => x * 2;
test_eq("arrow single param", dbl(7), 14);

let arrowAdd = (x, y) => x + y;
test_eq("arrow two params", arrowAdd(2, 3), 5);

let fact = n => { if (n <= 1) return 1; return n * fact(n - 1); };
test_eq("arrow block body recursion", fact(6), 720);

// 'this' binding
section("'this' binding");
let counter = {
    n: 0,
    inc: fn() { this.n = this.n + 1; return this.n; },
    makeArrowGetter: fn() { return () => this.n; },
    makeNormalGetter: fn() { return fn() { return this.n; }; }
};

counter.inc(); // 1
counter.inc(); // 2
let getArrow = counter.makeArrowGetter();
let getNormal = counter.makeNormalGetter();
test_eq("arrow captures lexical this", getArrow(), 2);

let other = { n: 100 };
other.get = getArrow;
test_eq("arrow ignores rebinding", other.get(), 2);

other.get = getNormal;
test_eq("normal respects call-site this", other.get(), 100);

// Methods on object
let person = {
    name: "John",
    age: 30,
    greet: fn() { return "Hello, I'm " + this.name + " and I'm " + this.age + " years old."; },
    haveBirthday: fn() { this.age = this.age + 1; return this.age; }
};
test_eq("method uses this", person.greet(), "Hello, I'm John and I'm 30 years old.");
test_eq("mutating method", person.haveBirthday(), 31);

// Destructuring declarations and assignment
section("Destructuring");
let [a, b = 2, ...rest] = [1, , 3, 4, 5];
test_eq("array destructuring decl", [a, b, rest], [1, 2, [3, 4, 5]]);

const { x: xx, y, z = 7, ...others } = { x: 1, y: 2, w: 9 };
test_eq("object destructuring decl with alias/default/rest",
    [xx, y, z, others], [1, 2, 7, { w: 9 }]);

[a, b] = [10, 20];
test_eq("array destructuring assignment", [a, b], [10, 20]);

let target = { a: 0, b: 0 };
{ a: target.a, b: target.b } = { a: 5, b: 6 };
test_eq("object destructuring assignment into properties", target, { a: 5, b: 6 });

// Member calls + rest-last with named args
section("Parameters: rest-last and named arguments");
fn restLastDemo(a, b = 2, ...r) { return { a: a, b: b, rest: r }; }
test_eq("restLastDemo(1)", restLastDemo(1), { a: 1, b: 2, rest: [] });
test_eq("restLastDemo(1,3,4,5)", restLastDemo(1, 3, 4, 5), { a: 1, b: 3, rest: [4, 5] });
test_eq("restLastDemo(b:10,a:7,8,9)", restLastDemo(b: 10, a: 7, 8, 9), { a: 7, b: 10, rest: [8, 9] });

// Named args + default evaluation in callee env
section("Named args: default evaluation in callee env");

// The global 'a' exists from earlier tests; ensure it would interfere if looked up from caller.
// Defaults must see the callee's parameter 'a', not this global.
a = 100;

fn def_scope(a, b = a) { return [a, b]; }
test_eq("default sees earlier param (positional)", def_scope(3), [3, 3]);
test_eq("default sees earlier param (named)", def_scope(a: 1), [1, 1]);
test_eq("explicit named overrides default", def_scope(b: 5, a: 2), [2, 5]);

fn def_with_rest(a, b = a, ...r) { return { a: a, b: b, r: r }; }
test_eq("default + rest with named a", def_with_rest(a: 7, 8, 9), { a: 7, b: 7, r: [8, 9] });
test_eq("default + rest with named b and a", def_with_rest(b: 10, a: 7, 8), { a: 7, b: 10, r: [8] });

// Chained defaults must evaluate left-to-right in the callee env
fn chain(a = 1, b = a + 1, c = b + 1) { return [a, b, c]; }
test_eq("chained defaults: none provided", chain(), [1, 2, 3]);
test_eq("chained defaults: only b provided", chain(b: 5), [1, 5, 6]);
test_eq("chained defaults: a provided", chain(a: 10), [10, 11, 12]);
test_eq("chained defaults: c provided", chain(c: 100), [1, 2, 100]);
test_eq("chained defaults: b,a provided (reverse order allowed)", chain(b: 5, a: 10), [10, 5, 6]);
test_eq("chained defaults: c,a provided", chain(c: 20, a: 2), [2, 3, 20]);

// JSON roundtrip
section("JSON");
let objJ = { msg: "ok", data: [1, 2, 3], nested: { a: 1 } };
let j = json_stringify(objJ);
let parsed = json_parse(j);
test_eq("json round-trip deep equal", parsed, objJ);

// Random determinism by reseeding
section("Random with seed");
srand(123);
let r1 = random();
srand(123);
let r2 = random();
test_true("random repeatable after same seed", almost_number_equal(r1, r2));

// --- Logical alias operators (&&, ||, !) --------------------------------
section("Logical alias operators (&&, ||, !)");
test_eq("false && does not eval right", (fn(){
    let s = 0;
    fn inc2() { s = s + 1; return true; }
    false && inc2();
    return s;
})(), 0);

test_eq("true || does not eval right", (fn(){
    let s = 0;
    fn inc2() { s = s + 1; return true; }
    true || inc2();
    return s;
})(), 0);

test_eq("true && evals right once", (fn(){
    let s = 0;
    fn inc2() { s = s + 1; return true; }
    true && inc2();
    return s;
})(), 1);

test_true("!false is true", !false);
test_true("!(1 < 2 && false) is true", !(1 < 2 && false));
test_true("1 < 2 && 3 < 4", 1 < 2 && 3 < 4);
test_true("1 < 2 || 3 < 1", 1 < 2 || 3 < 1);
test_true("1 != 2", 1 != 2);

// --- Built-in deep_equal -----------------------------------------------------
section("Built-in deep_equal (structural)");

// Simple structures
test_true("builtin deep_equal arrays", deep_equal([1, [2, 3]], [1, [2, 3]]));
test_true("builtin deep_equal objects key order-insensitive",
    deep_equal({ a: 1, b: 2 }, { b: 2, a: 1 }));
test_true("builtin deep_equal nested objects",
    deep_equal({ x: { y: [1, 2] } }, { x: { y: [1, 2] } }));

// Mismatch cases
test_true("builtin deep_equal detects inequality (arrays)",
    not deep_equal([1, 2], [1, 3]));
test_true("builtin deep_equal does not coerce number vs string",
    not deep_equal(10, "10"));

// Cyclic structures
let cycA = []; push(cycA, cycA);
let cycB = []; push(cycB, cycB);
test_true("builtin deep_equal handles cycles", deep_equal(cycA, cycB));

// --- Object insertion order and iteration -------------------------------
section("Object insertion order and iteration");
let ord = { b: 1, a: 2, c: 3 };
test_eq("keys preserve insertion order", keys(ord), ["b", "a", "c"]);
test_eq("entries preserve insertion order", map(entries(ord), e => e[0]), ["b", "a", "c"]);
test_eq("json_stringify preserves order", json_stringify(ord), "{\"b\":1,\"a\":2,\"c\":3}");
test_eq("merge preserves base order and appends",
    keys(merge({ a: 1 }, { b: 2, a: 3, c: 4 })), ["a", "b", "c"]);
test_eq("updating existing key does not reorder", (fn(){
    let o = { a: 1, b: 2, c: 3 };
    o.b = 9;
    return keys(o);
})(), ["a", "b", "c"]);
test_eq("adding new key appends at end", (fn(){
    let o = { a: 1, b: 2 };
    o.c = 3;
    return keys(o);
})(), ["a", "b", "c"]);

// Try/Catch/Finally & Throw
section("Try/Catch/Finally and Throw");

// Catch a thrown literal
test_eq("catch literal thrown", (fn(){
    let got = nil;
    try { throw 123; }
    catch (e) { got = e; }
    return got;
})(), 123);

// finally runs on normal path
test_eq("finally executes on normal path", (fn(){
    let f = 0;
    try { f = 1; }
    finally { f = f + 1; }
    return f;
})(), 2);

// finally runs on throw
test_eq("finally executes on throw", (fn(){
    let f = 0;
    try { throw "x"; }
    catch (e) { }
    finally { f = 42; }
    return f;
})(), 42);

// raise() throws an Error object
test_eq("raise() produces Error object", (fn(){
    let got = nil;
    try { raise("boom"); }
    catch (e) { got = [e.name, e.message]; }
    return got;
})(), ["Error", "boom"]);

// error() returns an Error object (not thrown)
test_eq("error() returns object", (fn(){
    let e = error("just an object");
    return [e.name, e.message];
})(), ["Error", "just an object"]);

// Catch a runtime error as value
test_eq("catch runtime error as value", (fn(){
    let got = nil;
    try {
        let x = 1 / 0; // Division by zero -> runtime error
    } catch (e) {
        got = [e.name, contains(e.message, "Division by zero")];
    }
    return got;
})(), ["RuntimeError", true]);

// catch without binding
test_eq("catch without binding", (fn(){
    let f = 0;
    try { throw "oops"; }
    catch { f = 7; }
    return f;
})(), 7);

// finally runs even when returning from try
let tracking2 = { flag: 0 };
fn f_finally() {
    try { return 10; }
    finally { tracking2.flag = tracking2.flag + 1; }
}
test_eq("finally runs on return", (fn(){
    tracking2.flag = 0;
    let r = f_finally();
    return [r, tracking2.flag];
})(), [10, 1]);

// --- Recursion and Tail-Call Optimization -----------------------------------
section("Recursion and Tail-Call Optimization");

// 1) Tail-recursive factorial (normal function)
fn tco_fact(n, acc = 1) {
    if (n <= 1) return acc;
    return tco_fact(n - 1, acc * n);
}
test_eq("tco_fact(5)", tco_fact(5), 120);

// 2) Tail-recursive factorial (arrow function)
let tco_fact2 = (n, acc = 1) => n <= 1 ? acc : tco_fact2(n - 1, acc * n);
test_eq("tco_fact2(6)", tco_fact2(6), 720);

// 3) Deep tail recursion should not overflow the host stack
fn tco_countdown(n) {
    if (n == 0) return 0;
    return tco_countdown(n - 1);
}
let tco_deep = 20000;
test_eq("tco_countdown(20000)", tco_countdown(tco_deep), 0);

// 4) Tail call via callee expression with side effects (callee evaluated once)
let tco_side = 0;
let tco_get_countdown = () => { tco_side = tco_side + 1; return tco_countdown; };
fn tco_countdown2(n) {
    if (n == 0) return 0;
    return tco_get_countdown()(n - 1); // callee side-effect must still happen once
}
let tco_steps = 1000;
test_eq("tco_countdown2(1000)", tco_countdown2(tco_steps), 0);
test_eq("callee side-effects (1000)", tco_side, 1);

// 5) Non-tail recursion path should still work (no optimization)
fn tco_sum1(n) {
    if (n == 0) return 0;
    return 1 + tco_sum1(n - 1); // not a tail position
}
test_eq("tco_sum1(100)", tco_sum1(100), 100);

// 6) Named/default params preserved across tail calls
fn tco_bump_to(a, b = 10) {
    if (a <= 0) return b;
    return tco_bump_to(a - 1, b: b + 1); // named argument in tail position
}
test_eq("tco_bump_to(5, b:0)", tco_bump_to(5, b: 0), 5);
test_eq("tco_bump_to(3)", tco_bump_to(3), 13);

// 7) Tail recursion via method call (same function identity via property)
let tco_obj = {};
tco_obj.m = fn(n) {
    if (n == 0) return 0;
    return tco_obj.m(n - 1);
};
test_eq("tco_obj.m(1500)", tco_obj.m(1500), 0);

// 8) Arrow method variant
let tco_obj2 = {};
tco_obj2.m = (n, acc = 0) => n == 0 ? acc : tco_obj2.m(n - 1, acc + 1);
test_eq("tco_obj2.m(200)", tco_obj2.m(200), 200);

// --- Iteration constructs: for-of, for-in, classic for ----------------------
section("Iteration constructs: for-of, for-in, classic for");

// for-of over arrays (values)
let acc1 = [];
for (let x of [1, 2, 3]) { push(acc1, x * 2); }
test_eq("for-of over array values", acc1, [2, 4, 6]);

// for-of over strings (characters)
let chars = [];
for (let ch of "hey") { push(chars, ch); }
test_eq("for-of over string yields chars", chars, ["h", "e", "y"]);

// for-of over objects yields values in insertion order
let vals = [];
for (let v of { a: 1, b: 2, c: 3 }) { push(vals, v); }
test_eq("for-of over object yields values (insertion order)", vals, [1, 2, 3]);

// for-in over objects yields keys (insertion order)
let keys1 = [];
for (let k in { x: 1, y: 2, z: 3 }) { push(keys1, k); }
test_eq("for-in over object yields keys (insertion order)", keys1, ["x", "y", "z"]);

// for-in over arrays yields indices as strings
let idxs = [];
for (let i in [10, 20, 30]) { push(idxs, i); }
test_eq("for-in over array yields string indices", idxs, ["0", "1", "2"]);

// for-in over strings yields indices as strings
let sidxs = [];
for (let i in "abc") { push(sidxs, i); }
test_eq("for-in over string yields string indices", sidxs, ["0", "1", "2"]);

// Destructuring in for-of (with entries)
let seen_pairs = [];
for (let [k, v] of entries({ p: 9, q: 8 })) { push(seen_pairs, k + ":" + to_string(v)); }
test_eq("for-of with array destructuring from entries", seen_pairs, ["p:9", "q:8"]);

// No-declaration assignment target in for-of
let last = 0;
for (last of [3, 4, 5]) { /* assign each iteration */ }
test_eq("for-of without declaration assigns into existing var", last, 5);

// Destructuring assignment pattern in for-of without declaration
let A = 0, B = 0;
for ([A, B] of [[1, 2], [3, 4]]) { /* assign into A,B */ }
test_eq("for-of destructuring assignment into vars", [A, B], [3, 4]);

// break and continue inside for-of
let odds_until_3 = [];
for (let x of [1, 2, 3, 4, 5]) {
    if (x % 2 == 0) continue;
    push(odds_until_3, x);
    if (x == 3) break;
}
test_eq("for-of with continue/break", odds_until_3, [1, 3]);

// var vs let/const closure capture semantics
let fns_var = [];
for (var xv of [10, 20, 30]) { push(fns_var, () => xv); }
test_eq("for-of var captures same binding (last value)", map(fns_var, f => f()), [30, 30, 30]);

let fns_let = [];
for (let yv of [10, 20, 30]) { push(fns_let, () => yv); }
test_eq("for-of let captures fresh binding per iteration", map(fns_let, f => f()), [10, 20, 30]);

let fns_const = [];
for (const zv of [1, 2, 3]) { push(fns_const, () => zv); }
test_eq("for-of const captures fresh binding per iteration", map(fns_const, f => f()), [1, 2, 3]);

// for-of over nil => no iterations
let c_nil_of = 0;
for (let _ of nil) { c_nil_of = c_nil_of + 1; }
test_eq("for-of over nil yields no iterations", c_nil_of, 0);

// for-in over nil => no iterations
let c_nil_in = 0;
for (let _ in nil) { c_nil_in = c_nil_in + 1; }
test_eq("for-in over nil yields no iterations", c_nil_in, 0);

// Error cases: non-iterable/non-indexable
test_true("for-of non-iterable raises runtime error", (fn(){
    let ok = false;
    try { for (let x of 123) { /* no-op */ } }
    catch (e) { ok = contains(e.message, "not iterable"); }
    return ok;
})());

test_true("for-in non-indexable raises runtime error", (fn(){
    let ok = false;
    try { for (let k in 123) { /* no-op */ } }
    catch (e) { ok = contains(e.message, "indexable"); }
    return ok;
})());

// Classic C-style for
let seq = [];
for (let i = 0; i < 3; i = i + 1) { push(seq, i); }
test_eq("classic for i=0..2", seq, [0, 1, 2]);

// continue still performs increment step
let seq2 = [];
for (let i = 0; i < 5; i = i + 1) {
    if (i % 2 == 0) continue;
    push(seq2, i);
}
test_eq("classic for with continue still increments", seq2, [1, 3]);

// Omitting parts
let i_om = 0; let seq3 = [];
for (; i_om < 3; i_om = i_om + 1) { push(seq3, i_om); }
test_eq("classic for without initializer", seq3, [0, 1, 2]);

let ran_once = 0;
for (;;) { ran_once = 1; break; }
test_eq("classic for with no parts and break", ran_once, 1);

// --- Try/Finally with break/continue ----------------------------------------
section("Try/Finally with break/continue");

// finally runs on break (while)
test_eq("finally runs on break in while", (fn(){
    let f = 0;
    while (true) {
        try { break; }
        finally { f = f + 1; }
    }
    return f;
})(), 1);

// finally runs on continue (while), executes each iteration that exits try
test_eq("finally runs on continue in while", (fn(){
    let i = 0, f = 0;
    while (i < 3) {
        try {
            i = i + 1;
            if (i < 3) continue; // will hit finally
        } finally {
            f = f + 1;
        }
    }
    return [i, f];
})(), [3, 3]);

// catch must not trigger on break
test_eq("catch not executed on break", (fn(){
    let c = 0, f = 0;
    while (true) {
        try { break; }
        catch (e) { c = c + 1; }
        finally { f = f + 1; }
    }
    return [c, f];
})(), [0, 1]);

// catch must not trigger on continue
test_eq("catch not executed on continue", (fn(){
    let c = 0, f = 0, i = 0;
    while (i < 1) {
        try { i = i + 1; continue; }
        catch (e) { c = c + 1; }
        finally { f = f + 1; }
    }
    return [c, f];
})(), [0, 1]);

// nested finallys: both must run on break (inner then outer)
test_eq("nested finally order on break", (fn(){
    let log = [];
    while (true) {
        try {
            try { break; }
            finally { push(log, "inner"); }
        } finally {
            push(log, "outer");
        }
    }
    return log;
})(), ["inner", "outer"]);

// classic for: finally runs on continue (order check, finally before increment)
test_eq("finally runs on continue in classic for (order)", (fn(){
    let order = [];
    for (let i = 0; i < 3; i = i + 1) {
        try {
            push(order, "B" + to_string(i));
            if (i < 2) continue; // will hit finally, then increment
            push(order, "X");
        } finally {
            push(order, "F" + to_string(i));
        }
    }
    return order;
})(), ["B0","F0","B1","F1","B2","X","F2"]);

// for-of: finally runs on continue and break; catch not entered
test_eq("for-of finally on continue and break (order)", (fn(){
    let order = [];
    for (let x of [1, 2, 3]) {
        try {
            if (x == 2) continue;                 // skip body, but finally runs
            push(order, to_string(x));
            if (x == 3) break;                    // break, finally still runs
        } finally {
            push(order, "F" + to_string(x));
        }
    }
    return order;
})(), ["1","F1","F2","3","F3"]);

// nested finallys with continue: both finalizers must run
test_eq("nested finally order on continue", (fn(){
    let log = [];
    let i = 0;
    while (i < 1) {
        try {
            try { i = i + 1; continue; }
            finally { push(log, "inner"); }
        } finally {
            push(log, "outer");
        }
    }
    return log;
})(), ["inner", "outer"]);

// --- Summary -----------------------------------------------------------------
println();
println("===== SUMMARY =====");
println("Total: ", TOTAL, "  Passed: ", PASSED, "  Failed: ", FAILED);
if (FAILED > 0) {
    println("Failed tests:");
    let i = 0;
    while (i < length(FAILS)) { println(" - ", FAILS[i]); i = i + 1; }
}
